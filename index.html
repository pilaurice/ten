<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) - Updated for your domain -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-YOUR_GA_ID"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-YOUR_GA_ID', {
        page_title: 'Ultimate Tic-Tac-Toe - TEN',
        page_location: 'https://ten.sennepgames.com'
      });
      
      // Custom events for game analytics
      function trackGameEvent(action, difficulty = null) {
        gtag('event', action, {
          event_category: 'Game',
          event_label: difficulty,
          value: 1
        });
      }
    </script>

    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Tic-Tac-Toe - TEN | Sennep Games</title>
    <meta name="description" content="Play Ultimate Tic-Tac-Toe! Strategic tic-tac-toe with AI that thinks 6 moves ahead. Can you beat the AI on hard mode?">
    
    <!-- Favicon setup -->
    <link rel="icon" type="image/x-icon" href="./favicon.ico">
    <link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
    <link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="192x192" href="./android-chrome-192x192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="./android-chrome-512x512.png">
    
    <!-- PWA Manifest -->
    <link rel="manifest" href="./manifest.json">
    <meta name="theme-color" content="#337AFF">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="TEN">
    
    <!-- Updated Open Graph / Facebook meta tags -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://ten.sennepgames.com/">
    <meta property="og:title" content="Ultimate Tic-Tac-Toe - TEN | Sennep Games">
    <meta property="og:description" content="Play Ultimate Tic-Tac-Toe! Strategic tic-tac-toe with AI that thinks 6 moves ahead. Can you beat the AI on hard mode?">
    <meta property="og:image" content="https://ten.sennepgames.com/og-image.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:site_name" content="Sennep Games">

    <!-- Updated Twitter meta tags -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://ten.sennepgames.com/">
    <meta property="twitter:title" content="Ultimate Tic-Tac-Toe - TEN | Sennep Games">
    <meta property="twitter:description" content="Play Ultimate Tic-Tac-Toe! Strategic tic-tac-toe with AI that thinks 6 moves ahead. Can you beat the AI on hard mode?">
    <meta property="twitter:image" content="https://ten.sennepgames.com/og-image.png">

    <!-- Additional SEO meta tags -->
    <meta name="keywords" content="tic-tac-toe, ultimate tic-tac-toe, strategy game, AI game, puzzle game, brain game, sennep games">
    <meta name="author" content="Sennep Games">
    <meta name="robots" content="index, follow">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://ten.sennepgames.com/">

    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    
    <!-- Separated CSS file -->
    <link rel="stylesheet" href="styles.css">
</head>
<body class="splash-visible">
    <!-- Navigation buttons -->
    <button class="home-button" onclick="goToHome()" aria-label="Return to home">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </button>

    <button class="share-button" onclick="shareGame()" aria-label="Share game">
        <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
            <path d="M8.59 13.51l6.83 3.98m-.01-10.98l-6.82 3.98M21 5a3 3 0 11-6 0 3 3 0 016 0zM9 12a3 3 0 11-6 0 3 3 0 016 0zm12 7a3 3 0 11-6 0 3 3 0 016 0z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </button>

    <!-- Toast notification -->
    <div class="toast" id="toast"></div>

    <!-- How to Play Modal -->
    <div class="modal-overlay" id="howToPlayModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 class="modal-title">How to Play</h2>
                <button class="modal-close" onclick="closeHowToPlay()" aria-label="Close">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="modal-tldr">
                    <h3>TL;DR</h3>
                    <p>It's like regular tic-tac-toe, but with 9 boards! Win 3 boards in a row to win the game. The twist: where you play determines which board your opponent must play in next. ðŸŽ¯</p>
                </div>

                <h3>The Big Picture</h3>
                <p>You're playing 9 mini tic-tac-toe games at once! Win 3 mini-boards in a row (horizontally, vertically, or diagonally) to win the whole game.</p>

                <h3>The Twist</h3>
                <p>Here's where it gets interesting: Your move determines where your opponent plays next!</p>
                <ul>
                    <li>If you play in the top-left cell of any mini-board, your opponent must play in the top-left mini-board</li>
                    <li>If you play in the center cell, they go to the center board</li>
                    <li>And so on!</li>
                </ul>

                <h3>When You Get Free Choice</h3>
                <p>Sometimes you'll see multiple boards light up - this means you can play anywhere! This happens when:</p>
                <ul>
                    <li>It's your first move</li>
                    <li>You're sent to a board that's already won</li>
                    <li>You're sent to a board that's completely full</li>
                </ul>

                <h3>Strategy Tips</h3>
                <ul>
                    <li>Think ahead! Where will your move send your opponent?</li>
                    <li>Don't accidentally give them free choice by sending them to finished boards</li>
                    <li>Control the center boards - they're part of the most winning combinations</li>
                    <li>Sometimes it's better to block than to win if it sends your opponent somewhere good</li>
                </ul>

                <h3>Quick Rules</h3>
                <ul>
                    <li>âœ“ Win mini-boards by getting 3 in a row</li>
                    <li>âœ“ Win the game by getting 3 mini-boards in a row</li>
                    <li>âœ“ Your move position = opponent's next board</li>
                    <li>âœ“ Blue border = X can play there</li>
                    <li>âœ“ Red border = O can play there</li>
                </ul>

                <p>Ready to play? It's easier to learn by doing - jump in and have fun! ðŸŽ¯</p>
            </div>
            <div class="modal-footer">
                <button class="modal-button" onclick="closeHowToPlay()">
                    <span class="modal-button-text">Got it!</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Splash Page -->
    <div class="splash-page">
        <div class="splash-content">
            <div class="splash-tiles">
                <div class="splash-x-tile" aria-label="X player tile"></div>
                <div class="splash-o-tile" aria-label="O player tile"></div>
            </div>
            <h1 class="splash-title">Welcome to TEN</h1>
            <p class="splash-subtitle">An ultimate tic-tac-toe game made by Sennep Games</p>
            
            <div class="button-group main-menu">
                <button class="menu-button" onclick="showHowToPlay()" aria-label="How to play">
                    <span class="menu-button-text">How to play</span>
                </button>
                <button class="menu-button" onclick="start2Player()" aria-label="Start 2 player game">
                    <span class="menu-button-text">2 Player</span>
                </button>
                <button class="menu-button" onclick="showAIDifficulty()" aria-label="Play against AI">
                    <span class="menu-button-text">Play the AI</span>
                </button>
            </div>

            <div class="button-group ai-difficulty" style="display: none;">
                <button class="menu-button" onclick="startAIEasy()" aria-label="Play against easy AI">
                    <span class="menu-button-text">Easy</span>
                </button>
                <button class="menu-button" onclick="startAIMedium()" aria-label="Play against medium AI">
                    <span class="menu-button-text">Medium</span>
                </button>
                <button class="menu-button" onclick="startAIHard()" aria-label="Play against hard AI">
                    <span class="menu-button-text">Hard</span>
                </button>
            </div>
        </div>
    </div>

    <!-- Game Container -->
    <div class="game-container">
        <!-- Turn indicator -->
        <div class="turn-indicator" role="status" aria-live="polite">
            <div class="mini-x-tile" aria-hidden="true"></div>
            <div class="mini-o-tile" aria-hidden="true"></div>
            <span class="turn-text">Your turn</span>
        </div>

        <!-- Game board and AI thinking container -->
        <div class="ai-thinking-container">
            <div class="main-board" role="grid" aria-label="Ultimate tic-tac-toe game board">
                <!-- Mini-boards will be generated by JavaScript -->
            </div>
            
            <!-- AI thinking indicator -->
            <div class="ai-thinking" role="status" aria-live="polite">
                <span class="ai-thinking-text">Thinking<span class="thinking-dots"></span></span>
            </div>
        </div>
        
        <!-- Play again button -->
        <div class="play-again-placeholder">
            <div class="play-again" onclick="resetGame()" role="button" tabindex="0" aria-label="Play again">
                <span class="play-again-text">Play again</span>
            </div>
        </div>
    </div>

    <!-- JavaScript -->
    <script>
        // =================================================================
        // GAME CONFIGURATION & CONSTANTS
        // =================================================================
        
        // Constants for timing and configuration
        const TIMING = {
            AI_THINKING_MIN: 500,
            AI_THINKING_MAX: 4000,
            BOARD_TRANSITION: 1500,
            AI_FADE_OUT: 500,
            CLICK_DEBOUNCE: 300,
            GAME_RESULT_DEBOUNCE: 1000
        };

        // =================================================================
        // GAME STATE VARIABLES
        // =================================================================
        
        // Game state
        let currentPlayer = 'X';
        let nextBoard = null; // null means any board can be played
        let gameBoard = Array(9).fill(null).map(() => Array(9).fill(null));
        let boardWinners = Array(9).fill(null);
        let gameWinner = null;
        let lastPlayedCell = null; // Track last played cell
        let isAIGame = false;
        let aiDifficulty = null;

        // Debouncing and timing controls
        let clickDebounce = false;
        let aiThinkingTimeout = null;
        let aiMoveTimeout = null;
        let gameResultTimeout = null;

        // DOM cache
        const domCache = {
            mainBoard: null,
            turnText: null,
            aiThinking: null,
            playAgain: null,
            modal: null,
            toast: null
        };

        // =================================================================
        // INITIALIZATION & SETUP
        // =================================================================
        
        // Initialize DOM cache
        function initializeDOMCache() {
            domCache.mainBoard = document.querySelector('.main-board');
            domCache.turnText = document.querySelector('.turn-text');
            domCache.aiThinking = document.querySelector('.ai-thinking');
            domCache.playAgain = document.querySelector('.play-again');
            domCache.modal = document.getElementById('howToPlayModal');
            domCache.toast = document.getElementById('toast');
        }

        // Clear all timeouts
        function clearAllTimeouts() {
            clearTimeout(aiThinkingTimeout);
            clearTimeout(aiMoveTimeout);
            clearTimeout(gameResultTimeout);
            aiThinkingTimeout = null;
            aiMoveTimeout = null;
            gameResultTimeout = null;
        }

        // Cleanup function for removing event listeners
        function cleanupBoard() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const newCell = cell.cloneNode(true);
                cell.parentNode.replaceChild(newCell, cell);
            });
        }

        // Clear last played cell styling
        function clearLastPlayedCell() {
            if (lastPlayedCell) {
                lastPlayedCell.classList.remove('last-played');
                lastPlayedCell = null;
            }
        }

        // =================================================================
        // BOARD MANAGEMENT
        // =================================================================
        
        // Initialize the game board
        function initializeBoard(animate = false) {
            // Clean up existing board
            cleanupBoard();
            
            const mainBoard = domCache.mainBoard;
            if (!mainBoard) return;
            
            mainBoard.innerHTML = '';

            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                const miniBoard = document.createElement('div');
                miniBoard.className = 'mini-board';
                miniBoard.setAttribute('role', 'group');
                miniBoard.setAttribute('aria-label', `Mini board ${boardIndex + 1}`);
                
                if (animate) {
                    miniBoard.classList.add('fade-in');
                    miniBoard.style.animationDelay = `${boardIndex * 0.1}s`;
                }
                miniBoard.id = `board-${boardIndex}`;
                
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    cell.dataset.board = boardIndex;
                    cell.dataset.cell = cellIndex;
                    
                    // Add cross-2 span for X marks
                    const cross2 = document.createElement('span');
                    cross2.className = 'cross-2';
                    cell.appendChild(cross2);
                    
                    cell.addEventListener('click', handleCellClick);
                    miniBoard.appendChild(cell);
                }
                
                mainBoard.appendChild(miniBoard);
            }
            
            // Clear any last played reference
            clearLastPlayedCell();
            
            updateBoardStates();
        }

        // Update active/inactive states of boards
        function updateBoardStates() {
            const boards = document.querySelectorAll('.mini-board');
            
            boards.forEach((board, i) => {
                if (gameWinner || isGameDraw()) {
                    // Game is over - all boards become inactive
                    board.classList.remove('active');
                    board.classList.add('inactive');
                } else if (boardWinners[i] || isBoardFull(i)) {
                    // Board is won or full - cannot be played in
                    board.classList.remove('active');
                    board.classList.remove('inactive');
                } else if (nextBoard === null || nextBoard === i) {
                    // Board is available for play
                    board.classList.add('active');
                    board.classList.remove('inactive');
                } else {
                    // Board is not currently playable
                    board.classList.remove('active');
                    board.classList.add('inactive');
                }
            });
        }

        // =================================================================
        // GAME LOGIC & RULES
        // =================================================================
        
        // Handle cell clicks with debouncing and validation
        function handleCellClick(event) {
            // Debounce rapid clicks
            if (clickDebounce) return;
            
            // Prevent clicks during AI turn or if game is over
            if ((isAIGame && currentPlayer === 'O') || gameWinner || isGameDraw()) {
                return;
            }
            
            const cell = event.currentTarget;
            const boardIndex = parseInt(cell.dataset.board);
            const cellIndex = parseInt(cell.dataset.cell);
            
            // Validate move
            if (!isValidMove(boardIndex, cellIndex)) {
                return;
            }
            
            // Set debounce
            clickDebounce = true;
            setTimeout(() => { clickDebounce = false; }, TIMING.CLICK_DEBOUNCE);
            
            // Track move event
            trackGameEvent('move', isAIGame ? aiDifficulty : '2player');
            
            // Make the move
            makeMove(boardIndex, cellIndex, cell);
        }

        // Make a move (used by both human and AI)
        function makeMove(boardIndex, cellIndex, cell) {
            // Clear previous last played cell
            clearLastPlayedCell();
            
            // Make the move
            gameBoard[boardIndex][cellIndex] = currentPlayer;
            cell.classList.add(currentPlayer === 'X' ? 'x-mark' : 'o-mark');
            cell.classList.add('last-played');
            cell.setAttribute('aria-label', `Board ${boardIndex + 1}, Cell ${cellIndex + 1}, ${currentPlayer}`);
            cell.setAttribute('aria-pressed', 'true');
            lastPlayedCell = cell;
            
            // Check if this mini-board is won
            if (!boardWinners[boardIndex]) {
                const winner = checkBoardWinner(boardIndex);
                if (winner) {
                    boardWinners[boardIndex] = winner;
                    displayBoardWinner(boardIndex, winner);
                    
                    // Check if the game is won
                    const gameWin = checkGameWinner();
                    if (gameWin) {
                        gameWinner = gameWin.winner;
                        // Mark winning tiles with animation
                        markWinningTiles(gameWin.winningBoards);
                        updateGameOverState();
                        updateBoardStates();
                        
                        // Track game end event
                        trackGameEvent('game_end', isAIGame ? aiDifficulty : '2player');
                        if (gameWinner === 'X') {
                            trackGameEvent('player_win', isAIGame ? aiDifficulty : '2player');
                        } else if (isAIGame) {
                            trackGameEvent('ai_win', aiDifficulty);
                        }
                        
                        return; // Exit early if game is won
                    }
                }
            }
            
            // Check for draw with debouncing
            if (!gameWinner && isGameDraw()) {
                // Debounce game result to prevent race conditions
                if (!gameResultTimeout) {
                    gameResultTimeout = setTimeout(() => {
                        if (!gameWinner && isGameDraw()) {
                            updateGameOverState(true);
                            updateBoardStates();
                            trackGameEvent('game_draw', isAIGame ? aiDifficulty : '2player');
                        }
                        gameResultTimeout = null;
                    }, 100);
                }
                return;
            }
            
            // Only continue with turn switching if game is not over
            if (!gameWinner && !isGameDraw()) {
                // Determine next board
                nextBoard = boardWinners[cellIndex] || isBoardFull(cellIndex) ? null : cellIndex;
                
                // Switch players
                currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
                document.body.className = currentPlayer === 'X' ? 'x-turn' : 'o-turn';
                updateTurnText();
                
                // Update board states
                updateBoardStates();
                
                // Schedule AI move if needed
                if (isAIGame && currentPlayer === 'O' && !gameWinner && !isGameDraw()) {
                    scheduleAIMove();
                }
            }
        }

        // Check if a move is valid
        function isValidMove(boardIndex, cellIndex) {
            // Bounds checking
            if (boardIndex < 0 || boardIndex > 8 || cellIndex < 0 || cellIndex > 8) {
                return false;
            }
            
            // Can't play if game is won or drawn
            if (gameWinner || isGameDraw()) return false;
            
            // Can't play in won boards
            if (boardWinners[boardIndex]) return false;
            
            // Can't play in occupied cells
            if (gameBoard[boardIndex][cellIndex]) return false;
            
            // Must play in the correct board if specified
            if (nextBoard !== null && boardIndex !== nextBoard) return false;
            
            return true;
        }

        // Check if a mini-board has a winner
        function checkBoardWinner(boardIndex) {
            const board = gameBoard[boardIndex];
            if (!board) return null;
            
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6] // diagonals
            ];
            
            for (const line of lines) {
                const [a, b, c] = line;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }
            
            return null;
        }

        // Check if the overall game has a winner
        function checkGameWinner() {
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6] // diagonals
            ];
            
            for (const line of lines) {
                const [a, b, c] = line;
                if (boardWinners[a] && boardWinners[a] === boardWinners[b] && boardWinners[a] === boardWinners[c]) {
                    return {
                        winner: boardWinners[a],
                        winningBoards: [a, b, c]
                    };
                }
            }
            
            return null;
        }

        // Check if a board is full
        function isBoardFull(boardIndex) {
            if (boardIndex < 0 || boardIndex > 8) return false;
            return gameBoard[boardIndex].every(cell => cell !== null);
        }

        // Check if game is a draw
        function isGameDraw() {
            // Game is a draw if all boards are either won or full and no winner
            for (let i = 0; i < 9; i++) {
                if (!boardWinners[i] && !isBoardFull(i)) {
                    return false;
                }
            }
            return !gameWinner;
        }

        // =================================================================
        // VISUAL EFFECTS & ANIMATIONS
        // =================================================================
        
        // Mark the winning tiles with animation
        function markWinningTiles(winningBoards) {
            // Sort winning boards by index to ensure proper cascade order
            const sortedBoards = [...winningBoards].sort((a, b) => a - b);
            
            sortedBoards.forEach((boardIndex, index) => {
                const board = document.getElementById(`board-${boardIndex}`);
                if (!board) return;
                
                const winnerTile = board.querySelector('.big-x, .big-o');
                if (winnerTile) {
                    // Calculate delay based on position in sequence
                    const delay = 0.25 + (index * 0.15);
                    
                    // Set CSS variable for animation delay
                    winnerTile.style.setProperty('--pulse-delay', `${delay}s`);
                    winnerTile.classList.add('winning');
                }
            });
        }

        // Display winner overlay on mini-board
        function displayBoardWinner(boardIndex, winner) {
            const board = document.getElementById(`board-${boardIndex}`);
            if (!board) return;
            
            board.classList.add('won');
            board.setAttribute('aria-label', `Mini board ${boardIndex + 1} won by ${winner}`);
            
            const winnerElement = document.createElement('div');
            winnerElement.className = winner === 'X' ? 'big-x' : 'big-o';
            winnerElement.setAttribute('aria-label', `${winner} wins this board`);
            board.appendChild(winnerElement);
        }

        // =================================================================
        // GAME STATE MANAGEMENT
        // =================================================================
        
        // Update game over state
        function updateGameOverState(isDraw = false) {
            // Clear all timeouts when game ends
            clearAllTimeouts();
            
            const turnText = domCache.turnText;
            if (!turnText) return;
            
            if (isDraw) {
                document.body.className = 'draw';
                turnText.textContent = 'Draw';
                announceGameResult('Game ended in a draw');
            } else if (gameWinner) {
                document.body.className = gameWinner === 'X' ? 'x-wins' : 'o-wins';
                turnText.textContent = 'Wins';
                announceGameResult(`${gameWinner} wins the game`);
            }
        }

        // Announce game result for screen readers
        function announceGameResult(message) {
            // Remove any existing announcements first
            const existingAnnouncements = document.querySelectorAll('.game-announcement');
            existingAnnouncements.forEach(el => el.remove());
            
            const announcement = document.createElement('div');
            announcement.className = 'sr-only game-announcement';
            announcement.setAttribute('role', 'alert');
            announcement.textContent = message;
            document.body.appendChild(announcement);
            
            // Remove after announcement
            setTimeout(() => {
                announcement.remove();
            }, 1000);
        }

        // Reset the game
        function resetGame() {
            // Clear all timeouts and debounces
            clearAllTimeouts();
            clickDebounce = false;
            
            // Track game reset
            trackGameEvent('game_reset', isAIGame ? aiDifficulty : '2player');
            
            // Reset game state
            currentPlayer = 'X';
            nextBoard = null;
            gameBoard = Array(9).fill(null).map(() => Array(9).fill(null));
            boardWinners = Array(9).fill(null);
            gameWinner = null;
            clearLastPlayedCell();
            
            // Reset body classes and turn text
            document.body.className = 'x-turn';
            const turnText = domCache.turnText;
            if (turnText) {
                turnText.textContent = isAIGame ? 'Your turn' : 'Your turn';
            }
            
            // Hide AI thinking indicator
            hideAIThinking();
            
            // Clear any existing game announcements
            const announcements = document.querySelectorAll('.game-announcement');
            announcements.forEach(el => el.remove());
            
            // Reinitialize board
            initializeBoard(false);
        }

        // Update turn text for AI games
        function updateTurnText() {
            const turnText = domCache.turnText;
            if (!turnText) return;
            
            if (isAIGame) {
                turnText.textContent = currentPlayer === 'X' ? 'Your turn' : "AI's turn";
            } else {
                turnText.textContent = 'Your turn';
            }
        }

        // =================================================================
        // SPLASH PAGE & NAVIGATION
        // =================================================================
        
        function showHowToPlay() {
            const modal = domCache.modal;
            if (!modal) return;
            
            trackGameEvent('how_to_play_opened');
            modal.classList.add('show');
            document.body.style.overflow = 'hidden';
        }

        function closeHowToPlay() {
            const modal = domCache.modal;
            if (!modal) return;
            
            modal.classList.remove('show');
            document.body.style.overflow = '';
        }

        function goToHome() {
            // Clear all timeouts and reset state
            clearAllTimeouts();
            resetGame();
            
            // Clear AI game state
            isAIGame = false;
            aiDifficulty = null;
            
            // Show splash screen and remove AI difficulty state
            document.body.classList.add('splash-visible');
            document.body.classList.remove('x-turn', 'o-turn', 'x-wins', 'o-wins', 'draw', 'ai-difficulty-visible');
            
            // Clean up board
            cleanupBoard();
            
            // Reset to main menu
            const mainMenu = document.querySelector('.main-menu');
            const aiMenu = document.querySelector('.ai-difficulty');
            if (mainMenu && aiMenu) {
                mainMenu.style.display = 'flex';
                mainMenu.classList.remove('fade-out');
                aiMenu.style.display = 'none';
            }
        }

        function start2Player() {
            isAIGame = false;
            aiDifficulty = null;
            
            trackGameEvent('game_start', '2player');
            
            document.body.classList.remove('splash-visible');
            document.body.classList.add('x-turn');
            initializeBoard(true);
        }

        function showAIDifficulty() {
            const mainMenu = document.querySelector('.main-menu');
            const aiMenu = document.querySelector('.ai-difficulty');
            if (!mainMenu || !aiMenu) return;
            
            // Add class to show home button on AI difficulty screen
            document.body.classList.add('ai-difficulty-visible');
            
            mainMenu.classList.add('fade-out');
            
            setTimeout(() => {
                mainMenu.style.display = 'none';
                aiMenu.style.display = 'flex';
                
                const aiButtons = aiMenu.querySelectorAll('.menu-button');
                aiButtons.forEach((button, index) => {
                    button.style.opacity = '0';
                    button.style.transform = 'translateY(20px)';
                    button.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
                    
                    setTimeout(() => {
                        button.style.opacity = '1';
                        button.style.transform = 'translateY(0)';
                    }, index * 150);
                });
            }, 300);
        }

        function startAIEasy() {
            isAIGame = true;
            aiDifficulty = 'easy';
            startAIGame();
        }

        function startAIMedium() {
            isAIGame = true;
            aiDifficulty = 'medium';
            startAIGame();
        }

        function startAIHard() {
            isAIGame = true;
            aiDifficulty = 'hard';
            startAIGame();
        }

        function startAIGame() {
            trackGameEvent('game_start', aiDifficulty);
            
            document.body.classList.remove('splash-visible');
            document.body.classList.add('x-turn');
            initializeBoard(true);
        }

        // =================================================================
        // AI SYSTEM
        // =================================================================
        
        // Schedule AI move with proper timeout management
        function scheduleAIMove() {
            // Clear any existing timeouts
            clearAllTimeouts();
            
            // Calculate thinking time based on game progress
            const thinkingTime = calculateAIThinkingTime();
            
            // Wait for board transition then show thinking
            aiThinkingTimeout = setTimeout(() => {
                if (currentPlayer === 'O' && !gameWinner && !isGameDraw()) {
                    showAIThinking();
                    
                    // After thinking time, hide thinking and make move
                    aiMoveTimeout = setTimeout(() => {
                        hideAIThinking();
                        
                        // Wait for fade out then make move
                        setTimeout(() => {
                            if (currentPlayer === 'O' && !gameWinner && !isGameDraw()) {
                                makeAIMove();
                            }
                        }, TIMING.AI_FADE_OUT);
                    }, thinkingTime);
                }
            }, TIMING.BOARD_TRANSITION);
        }

        // AI move with validation and strategic thinking
        function makeAIMove() {
            // Double-check it's still AI's turn and game is active
            if (!isAIGame || currentPlayer !== 'O' || gameWinner || isGameDraw()) {
                return;
            }
            
            try {
                const validMoves = getValidMoves();
                if (validMoves.length === 0) {
                    console.warn('No valid moves available for AI');
                    return;
                }
                
                const chosenMove = selectAIMove(validMoves);
                if (!chosenMove || !isValidMove(chosenMove.board, chosenMove.cell)) {
                    console.warn('AI chose invalid move, selecting fallback');
                    const fallbackMove = validMoves[0];
                    if (fallbackMove && isValidMove(fallbackMove.board, fallbackMove.cell)) {
                        executeAIMove(fallbackMove);
                    }
                    return;
                }
                
                executeAIMove(chosenMove);
            } catch (error) {
                console.error('Error in AI move:', error);
                // Fallback to random valid move
                const validMoves = getValidMoves();
                if (validMoves.length > 0) {
                    executeAIMove(validMoves[0]);
                }
            }
        }

        // Get all valid moves
        function getValidMoves() {
            const validMoves = [];
            
            if (nextBoard !== null && nextBoard >= 0 && nextBoard <= 8 && !boardWinners[nextBoard]) {
                // Specific board constraint
                for (let i = 0; i < 9; i++) {
                    if (!gameBoard[nextBoard][i]) {
                        validMoves.push({ board: nextBoard, cell: i });
                    }
                }
            } else {
                // Any available board
                for (let b = 0; b < 9; b++) {
                    if (!boardWinners[b]) {
                        for (let c = 0; c < 9; c++) {
                            if (!gameBoard[b][c]) {
                                validMoves.push({ board: b, cell: c });
                            }
                        }
                    }
                }
            }
            
            return validMoves;
        }

        // Select AI move based on difficulty
        function selectAIMove(validMoves) {
            switch (aiDifficulty) {
                case 'easy':
                    return getEasyMove(validMoves);
                case 'medium':
                    return getMediumMove(validMoves);
                case 'hard':
                    return getHardMove(validMoves);
                default:
                    return validMoves[Math.floor(Math.random() * validMoves.length)];
            }
        }

        // Execute AI move
        function executeAIMove(move) {
            const cell = document.querySelector(`[data-board="${move.board}"][data-cell="${move.cell}"]`);
            if (cell && isValidMove(move.board, move.cell)) {
                makeMove(move.board, move.cell, cell);
            }
        }

        // Easy AI: Random moves with occasional blocking
        function getEasyMove(validMoves) {
            if (Math.random() < 0.3) {
                const blockingMove = findBlockingMove(validMoves);
                if (blockingMove) return blockingMove;
            }
            
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        // Medium AI: Always blocks, occasionally tries to win
        function getMediumMove(validMoves) {
            const winningMove = findWinningMove(validMoves);
            if (winningMove) return winningMove;
            
            const blockingMove = findBlockingMove(validMoves);
            if (blockingMove) return blockingMove;
            
            const centerMove = findCenterMove(validMoves);
            if (centerMove && Math.random() < 0.7) return centerMove;
            
            const strategicMove = findStrategicMove(validMoves);
            if (strategicMove) return strategicMove;
            
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        // Hard AI: Advanced strategic thinking
        function getHardMove(validMoves) {
            // Check for immediate game-ending moves first
            const gameWinningMove = findGameWinningMove(validMoves);
            if (gameWinningMove) return gameWinningMove;
            
            const gameBlockingMove = findGameBlockingMove(validMoves);
            if (gameBlockingMove) return gameBlockingMove;
            
            // Use strategic evaluation
            const strategicMove = findBestStrategicMove(validMoves);
            return strategicMove || validMoves[0];
        }

        // AI helper functions (simplified for space)
        function findWinningMove(validMoves) {
            for (const move of validMoves) {
                if (!gameBoard[move.board]) continue;
                
                gameBoard[move.board][move.cell] = 'O';
                const isWin = checkBoardWinner(move.board) === 'O';
                gameBoard[move.board][move.cell] = null;
                
                if (isWin) return move;
            }
            return null;
        }

        function findBlockingMove(validMoves) {
            for (const move of validMoves) {
                if (!gameBoard[move.board]) continue;
                
                gameBoard[move.board][move.cell] = 'X';
                const isWin = checkBoardWinner(move.board) === 'X';
                gameBoard[move.board][move.cell] = null;
                
                if (isWin) return move;
            }
            return null;
        }

        function findCenterMove(validMoves) {
            const centerMoves = validMoves.filter(move => move.cell === 4);
            if (centerMoves.length > 0) {
                return centerMoves[Math.floor(Math.random() * centerMoves.length)];
            }
            
            const cornerMoves = validMoves.filter(move => 
                move.cell === 0 || move.cell === 2 || move.cell === 6 || move.cell === 8
            );
            if (cornerMoves.length > 0) {
                return cornerMoves[Math.floor(Math.random() * cornerMoves.length)];
            }
            
            return null;
        }

        function findStrategicMove(validMoves) {
            // Simplified strategic evaluation
            const scoredMoves = validMoves.map(move => {
                let score = 0;
                
                // Evaluate board importance
                if (move.board === 4) score += 10; // Center board
                if ([0, 2, 6, 8].includes(move.board)) score += 5; // Corner boards
                
                // Evaluate cell position
                if (move.cell === 4) score += 8; // Center cell
                if ([0, 2, 6, 8].includes(move.cell)) score += 4; // Corner cells
                
                return { move, score };
            });
            
            scoredMoves.sort((a, b) => b.score - a.score);
            return scoredMoves[0].move;
        }

        function findGameWinningMove(validMoves) {
            // Check if any move wins the entire game
            for (const move of validMoves) {
                const originalValue = gameBoard[move.board][move.cell];
                const originalWinner = boardWinners[move.board];
                
                gameBoard[move.board][move.cell] = 'O';
                
                if (!originalWinner && checkBoardWinner(move.board) === 'O') {
                    boardWinners[move.board] = 'O';
                    
                    const gameWin = checkGameWinner();
                    if (gameWin && gameWin.winner === 'O') {
                        gameBoard[move.board][move.cell] = originalValue;
                        boardWinners[move.board] = originalWinner;
                        return move;
                    }
                    
                    boardWinners[move.board] = originalWinner;
                }
                
                gameBoard[move.board][move.cell] = originalValue;
            }
            
            return null;
        }

        function findGameBlockingMove(validMoves) {
            // Check if any move blocks opponent from winning the game
            for (const move of validMoves) {
                const originalValue = gameBoard[move.board][move.cell];
                const originalWinner = boardWinners[move.board];
                
                gameBoard[move.board][move.cell] = 'X';
                
                if (!originalWinner && checkBoardWinner(move.board) === 'X') {
                    boardWinners[move.board] = 'X';
                    
                    const gameWin = checkGameWinner();
                    if (gameWin && gameWin.winner === 'X') {
                        gameBoard[move.board][move.cell] = originalValue;
                        boardWinners[move.board] = originalWinner;
                        return move;
                    }
                    
                    boardWinners[move.board] = originalWinner;
                }
                
                gameBoard[move.board][move.cell] = originalValue;
            }
            
            return null;
        }

        function findBestStrategicMove(validMoves) {
            // Advanced strategic evaluation for hard AI
            const evaluatedMoves = validMoves.map(move => {
                let score = 0;
                
                // Evaluate board importance
                if (move.board === 4) score += 10; // Center board
                if ([0, 2, 6, 8].includes(move.board)) score += 5; // Corner boards
                
                // Evaluate cell position
                if (move.cell === 4) score += 8; // Center cell
                if ([0, 2, 6, 8].includes(move.cell)) score += 4; // Corner cells
                
                // Evaluate where this sends opponent
                const targetBoard = move.cell;
                if (boardWinners[targetBoard] || isBoardFull(targetBoard)) {
                    score -= 20; // Bad - gives opponent free choice
                } else {
                    if (canWinBoard(targetBoard, 'X')) score -= 15; // Bad - opponent can win
                    if (canWinBoard(targetBoard, 'O')) score += 10; // Good - we can threaten
                }
                
                return { move, score };
            });
            
            evaluatedMoves.sort((a, b) => b.score - a.score);
            return evaluatedMoves[0].move;
        }

        // Utility function to check if a player can win a board
        function canWinBoard(boardIndex, player) {
            if (boardIndex < 0 || boardIndex > 8 || !gameBoard[boardIndex]) return false;
            
            const board = gameBoard[boardIndex];
            const lines = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8],
                [0, 3, 6], [1, 4, 7], [2, 5, 8],
                [0, 4, 8], [2, 4, 6]
            ];
            
            for (const line of lines) {
                const values = line.map(i => board[i]);
                const playerCount = values.filter(v => v === player).length;
                const emptyCount = values.filter(v => v === null).length;
                
                if (playerCount === 2 && emptyCount === 1) {
                    return true;
                }
            }
            
            return false;
        }

        // Calculate AI thinking time based on game progress
        function calculateAIThinkingTime() {
            let totalMoves = 0;
            for (let b = 0; b < 9; b++) {
                for (let c = 0; c < 9; c++) {
                    if (gameBoard[b] && gameBoard[b][c]) {
                        totalMoves++;
                    }
                }
            }
            
            const gameProgress = totalMoves / 81;
            
            if (gameProgress < 0.4) {
                return TIMING.AI_THINKING_MIN + Math.random() * 500;
            } else if (gameProgress < 0.7) {
                return 1500 + Math.random() * 1500;
            } else {
                return 2000 + Math.random() * 2000;
            }
        }

        // AI thinking display
        function showAIThinking() {
            const thinkingEl = domCache.aiThinking;
            if (thinkingEl) {
                thinkingEl.classList.add('show');
            }
        }

        function hideAIThinking() {
            const thinkingEl = domCache.aiThinking;
            if (thinkingEl) {
                thinkingEl.classList.remove('show');
            }
        }

        // =================================================================
        // SHARING & UTILITIES
        // =================================================================
        
        // Share functionality
        async function shareGame() {
            const shareData = {
                title: 'Ultimate Tic-Tac-Toe - TEN',
                text: 'Play Ultimate Tic-Tac-Toe - Can you beat the AI on hard mode?',
                url: window.location.href
            };

            try {
                if (navigator.share && /Android|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                    await navigator.share(shareData);
                    trackGameEvent('share_success', 'native');
                } else {
                    await copyToClipboard(window.location.href);
                    showToast('Link copied!');
                    trackGameEvent('share_success', 'clipboard');
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    try {
                        await copyToClipboard(window.location.href);
                        showToast('Link copied!');
                        trackGameEvent('share_success', 'clipboard');
                    } catch (copyErr) {
                        showToast('Share failed');
                        trackGameEvent('share_failed');
                    }
                }
            }
        }

        // Copy to clipboard with fallback
        async function copyToClipboard(text) {
            try {
                await navigator.clipboard.writeText(text);
            } catch (err) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.opacity = '0';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
            }
        }

        // Show toast notification
        function showToast(message) {
            const toast = domCache.toast;
            if (!toast) return;
            
            toast.textContent = message;
            toast.classList.add('show');
            
            setTimeout(() => {
                toast.classList.remove('show');
            }, 2000);
        }

        // =================================================================
        // EVENT LISTENERS & INITIALIZATION
        // =================================================================
        
        // Event listeners setup
        let eventListenersInitialized = false;

        function initializeEventListeners() {
            if (eventListenersInitialized) return;
            
            // Play again button keyboard support
            const playAgainBtn = domCache.playAgain;
            if (playAgainBtn) {
                playAgainBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        resetGame();
                    }
                });
            }

            // Modal close events
            const modal = domCache.modal;
            if (modal) {
                modal.addEventListener('click', (e) => {
                    if (e.target === modal) {
                        closeHowToPlay();
                    }
                });
            }

            // Escape key to close modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && modal && modal.classList.contains('show')) {
                    closeHowToPlay();
                }
            });
            
            eventListenersInitialized = true;
        }

        // Register Service Worker for PWA
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('./sw.js')
                        .then(registration => {
                            console.log('SW registered: ', registration);
                        })
                        .catch(registrationError => {
                            console.log('SW registration failed: ', registrationError);
                        });
                });
            }
        }

        // Initialize everything when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initializeDOMCache();
            initializeEventListeners();
            registerServiceWorker();
        });
    </script>
</body>
</html>